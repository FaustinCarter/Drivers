# -*- coding: utf-8 -*-
"""
Created on Wed Jan 24 2018

@author: Fei Yan
"""
import InstrumentDriver
import numpy as np
import scipy.constants as const
from scipy.linalg import eig
from qutip import *

#Constants.
h = const.h #planck constant
h_bar = const.hbar #h_bar
e = const.e #electron charge
phi0= h/(2*e) #flux quantum
RQ = h/(2*e)**2 #quantum resistance

# def generateOperators(nTrunc):
# 	# generate basic operators. matrix truncated at nTrunc 
# 	I = qeye(nTrunc)
# 	a = destroy(nTrunc)
# 	x = a + a.dag()
# 	p = -1j*(a - a.dag())
# 	aa = a.dag() * a
# 	aaaa = a.dag() * a.dag() * a * a
# 	return {'I':I, 'a':a, 'x':x, 'p':p, 'aa':aa, 'aaaa':aaaa}

# def generateSubHamiltonian_3Q(nTrunc):
# 	# generate partial Hamiltonian in 3-qubit system
# 	OP = generateOperators(nTrunc)
# 	#
# 	H_Q1_aa = Qflatten(tensor(OP['aa'], OP['I'], OP['I']))
# 	H_Q1_aaaa = Qflatten(tensor(OP['aaaa'], OP['I'], OP['I']))
# 	H_Q2_aa = Qflatten(tensor(OP['I'], OP['aa'], OP['I']))
# 	H_Q2_aaaa = Qflatten(tensor(OP['I'], OP['aaaa'], OP['I']))
# 	H_Q3_aa = Qflatten(tensor(OP['I'], OP['I'], OP['aa']))
# 	H_Q3_aaaa = Qflatten(tensor(OP['I'], OP['I'], OP['aaaa']))
# 	#
# 	H_12_pp = Qflatten(tensor(OP['p'], OP['p'], OP['I']))
# 	H_23_pp = Qflatten(tensor(OP['I'], OP['p'], OP['p']))
# 	H_13_pp = Qflatten(tensor(OP['p'], OP['I'], OP['p']))
# 	#
# 	H_dr_1 = Qflatten(tensor(OP['p'], OP['I'], OP['I']))
# 	H_dr_2 = Qflatten(tensor(OP['I'], OP['p'], OP['I']))
# 	H_dr_3 = Qflatten(tensor(OP['I'], OP['I'], OP['p']))
# 	return {'H_Q1_aa':H_Q1_aa, 'H_Q1_aaaa':H_Q1_aaaa,
# 			'H_Q2_aa':H_Q2_aa, 'H_Q2_aaaa':H_Q2_aaaa,
# 			'H_Q3_aa':H_Q3_aa, 'H_Q3_aaaa':H_Q3_aaaa,
# 			'H_12_pp':H_12_pp, 'H_23_pp':H_23_pp, 'H_13_pp':H_13_pp, 
# 			'H_dr_1':H_dr_1, 'H_dr_2':H_dr_2, 'H_dr_3':H_dr_3}

def Ej_SQUID(flux,Ej_sum,d):
	# effective Ej of a SQUID
	return Ej_sum * np.abs(np.cos(np.pi*flux)) * np.sqrt(1+d**2*np.tan(np.pi*flux)**2) #[GHz]

def freq_SQUID(Ej, Ec):
	return np.sqrt(8 * Ej *Ec) - Ec

def freq_LC(L,C):
	# frequency of LC oscillator
	# L [nH]
	# C [fH]
	return 1/(2*np.pi)/np.sqrt(L*C)/1e-3   #[GHz]

def Z_LC(L,C):
	# impedence of LC oscillator
	return np.sqrt(L/C)*1e3   #[Ohm]

def U(H,t):
	# unitary propagator generated by H over time t 
	H = Qobj(H)
	return Qobj(-1j * H * t).expm()

def T(A, U, *args, **kwargs):
	A = Qobj(A)
	U = Qobj(U)
	return U * A * U.dag()

def Qflatten(Q):
	return Qobj(Q.full())

def eigensolve(H):
	# find eigensolution of H
	H = H.full()
	vals, vecs = eig(H)    
	#idx = vals.argsort()[::-1] #Descending Order
	idx = vals.argsort() #Ascending Order
	vals = vals[idx]
	vecs = vecs[:,idx]
	return vals, vecs

def level_identify(vals, vecs, list_table, list_select):
	# identify and sort eigen solutions according to "list_select"
	v_idx = []
	for k, str_level in enumerate(list_select):
		idx_sort = np.argsort(np.abs(vecs[list_table.index(str_level),:]))
		count = 1
		while True:
			if idx_sort[-count] in v_idx:
				count += 1
			else:
				v_idx.append(idx_sort[-count])
				break			
	return vals[v_idx], vecs[:,v_idx]



class MultiQubitHamiltonian():

	def __init__(self):
		# init with some default settings
		self.nQubit = 3
		self.nTrunc = 4
		self.nShow = 4
		self.bDesignParam_Q1 = False
		self.bDesignParam_Q2 = False
		self.bDesignParam_Q3 = False
		self.sQubitType_Q1 = '2-JJ'
		self.sQubitType_Q2 = '2-JJ'
		self.sQubitType_Q3 = '2-JJ'
		# frequencies [GHz]
		self.dFreq_Q1 = 4.0
		self.dFreq_Q2 = 4.0
		self.dFreq_Q3 = 4.0
		self.dAnh_Q1 = -0.3
		self.dAnh_Q2 = -0.3
		self.dAnh_Q3 = -0.3
		# capacitances [fF]
		self.dC1 = 80.0
		self.dC2 = 80.0
		self.dC3 = 80.0
		self.dC12 = 1.0
		self.dC23 = 1.0
		self.dC13 = 0.02
		# inductances [nH]
		#
		# designer parameter set
		# josephson energy [GHz]
		self.dEj_Q1 = 10.0
		self.dEj_Q2 = 10.0
		self.dEj_Q3 = 10.0
		# charging energy [GHz]
		self.dEc_Q1 = 0.2
		self.dEc_Q2 = 0.2
		self.dEc_Q3 = 0.2
		# SQUID asymmetry |A1-A2|/(A1+A2)
		self.dAsym_Q1 = 0.0
		self.dAsym_Q2 = 0.0
		self.dAsym_Q3 = 0.0
		# flux bias [Phi0]
		self.dFlux_Q1 = 0.0
		self.dFlux_Q2 = 0.0
		self.dFlux_Q3 = 0.0
		#
		# calculate partial coupling coefficients (approximate)
		self.c12 = self.dC12 / np.sqrt(self.dC1 * self.dC2)
		self.c23 = self.dC23 / np.sqrt(self.dC2 * self.dC3)
		self.c13 = self.dC13 / np.sqrt(self.dC1 * self.dC3)
		# #
		# if simCfg is not None:
		# 	# update simulation options
		# 	self.updateSimCfg(simCfg)


	def updateSimCfg(self, simCfg):
		# update simulation options
		for key, value in simCfg.items():
			if hasattr(self, key):
				setattr(self, key, value)
		# update frequencies if using designer parameter set
		if self.bDesignParam_Q1:
			if self.sQubitType_Q1 == '2-JJ':
				setattr(self, 'dFreq_Q1', freq_SQUID(Ej_SQUID(self.dFlux_Q1,self.dEj_Q1,self.dAsym_Q1), self.dEc_Q1))
				setattr(self, 'dAnh_Q1', -self.dEc_Q1)
		if self.bDesignParam_Q2:
			if self.sQubitType_Q2 == '2-JJ':
				setattr(self, 'dFreq_Q2', freq_SQUID(Ej_SQUID(self.dFlux_Q2,self.dEj_Q2,self.dAsym_Q2), self.dEc_Q2))
				setattr(self, 'dAnh_Q2', -self.dEc_Q2)
		if self.bDesignParam_Q3:
			if self.sQubitType_Q3 == '2-JJ':
				setattr(self, 'dFreq_Q3', freq_SQUID(Ej_SQUID(self.dFlux_Q3,self.dEj_Q3,self.dAsym_Q3), self.dEc_Q3))
				setattr(self, 'dAnh_Q3', -self.dEc_Q3)


	def generateOperators(self):
		# generate basic operators. matrix truncated at nTrunc 
		I = qeye(self.nTrunc)
		a = destroy(self.nTrunc)
		x = a + a.dag()
		p = -1j*(a - a.dag())
		aa = a.dag() * a
		aaaa = a.dag() * a.dag() * a * a
		return {'I':I, 'a':a, 'x':x, 'p':p, 'aa':aa, 'aaaa':aaaa}


	def generateSubHamiltonian_1Q(self):
		# generate partial Hamiltonian in 3-qubit system
		OP = self.generateOperators()
		# self Hamiltonian operators
		self.H_Q1_aa = Qflatten(tensor(OP['aa']))
		self.H_Q1_aaaa = Qflatten(tensor(OP['aaaa']))
		# drive Hamiltonian operators
		self.H_dr_Q1_x = Qflatten(tensor(OP['x']))
		self.H_dr_Q1_p = Qflatten(tensor(OP['p']))


	def generateHamiltonian_1Q_cap(self):
		# construct 3-qubit Hamiltonian
		self.generateSubHamiltonian_1Q()
		# self Hamiltonian
		self.H_Q1 = self.dFreq_Q1 * self.H_Q1_aa + self.dAnh_Q1/2 * self.H_Q1_aaaa
		# system Hamiltonian
		self.H_sys = self.H_Q1 + self.H_Q2 + self.H_12


	def generateLabel_1Q(self):
		# generate 3-qubit number state label list
		list_label_gen = ["0","1","2","3","4","5","6","7"]
		self.list_label_table = []
		for k1 in np.arange(self.nTrunc):
			self.list_label_table.append(list_label_gen[k1])


	def generateSubHamiltonian_2Q(self):
		# generate partial Hamiltonian in 3-qubit system
		OP = self.generateOperators()
		# self Hamiltonian operators
		self.H_Q1_aa = Qflatten(tensor(OP['aa'], OP['I']))
		self.H_Q1_aaaa = Qflatten(tensor(OP['aaaa'], OP['I']))
		self.H_Q2_aa = Qflatten(tensor(OP['I'], OP['aa']))
		self.H_Q2_aaaa = Qflatten(tensor(OP['I'], OP['aaaa']))
		# coupling Hamiltonian operators
		self.H_12_xx = Qflatten(tensor(OP['x'], OP['x']))#
		self.H_12_pp = Qflatten(tensor(OP['p'], OP['p']))
		# drive Hamiltonian operators
		self.H_dr_Q1_x = Qflatten(tensor(OP['x'], OP['I']))
		self.H_dr_Q2_x = Qflatten(tensor(OP['I'], OP['x']))
		self.H_dr_Q1_p = Qflatten(tensor(OP['p'], OP['I']))
		self.H_dr_Q2_p = Qflatten(tensor(OP['I'], OP['p']))


	def generateHamiltonian_2Q_cap(self):
		# construct 3-qubit Hamiltonian
		self.generateSubHamiltonian_2Q()
		# self Hamiltonian
		self.H_Q1 = self.dFreq_Q1 * self.H_Q1_aa + self.dAnh_Q1/2 * self.H_Q1_aaaa
		self.H_Q2 = self.dFreq_Q2 * self.H_Q2_aa + self.dAnh_Q2/2 * self.H_Q2_aaaa
		# coupling Hamiltonian
		self.g_12 = 0.5 * self.c12 * np.sqrt(self.dFreq_Q1 * self.dFreq_Q2)
		self.H_12 = self.g_12 * self.H_12_pp
		# system Hamiltonian
		self.H_sys = self.H_Q1 + self.H_Q2 + self.H_12


	def generateLabel_2Q(self):
		# generate 3-qubit number state label list
		list_label_gen = ["0","1","2","3","4","5","6","7"]
		self.list_label_table = []
		for k1 in np.arange(self.nTrunc):
			for k2 in np.arange(self.nTrunc):
				self.list_label_table.append(list_label_gen[k1] + list_label_gen[k2])


	def generateSubHamiltonian_3Q(self):
		# generate partial Hamiltonian in 3-qubit system
		OP = self.generateOperators()
		# self Hamiltonian operators
		self.H_Q1_aa = Qflatten(tensor(OP['aa'], OP['I'], OP['I']))
		self.H_Q1_aaaa = Qflatten(tensor(OP['aaaa'], OP['I'], OP['I']))
		self.H_Q2_aa = Qflatten(tensor(OP['I'], OP['aa'], OP['I']))
		self.H_Q2_aaaa = Qflatten(tensor(OP['I'], OP['aaaa'], OP['I']))
		self.H_Q3_aa = Qflatten(tensor(OP['I'], OP['I'], OP['aa']))
		self.H_Q3_aaaa = Qflatten(tensor(OP['I'], OP['I'], OP['aaaa']))
		# coupling Hamiltonian operators
		self.H_12_xx = Qflatten(tensor(OP['x'], OP['x'], OP['I']))
		self.H_23_xx = Qflatten(tensor(OP['I'], OP['x'], OP['x']))
		self.H_13_xx = Qflatten(tensor(OP['x'], OP['I'], OP['x']))		#
		self.H_12_pp = Qflatten(tensor(OP['p'], OP['p'], OP['I']))
		self.H_23_pp = Qflatten(tensor(OP['I'], OP['p'], OP['p']))
		self.H_13_pp = Qflatten(tensor(OP['p'], OP['I'], OP['p']))
		# drive Hamiltonian operators
		self.H_dr_Q1_x = Qflatten(tensor(OP['x'], OP['I'], OP['I']))
		self.H_dr_Q2_x = Qflatten(tensor(OP['I'], OP['x'], OP['I']))
		self.H_dr_Q3_x = Qflatten(tensor(OP['I'], OP['I'], OP['x']))
		self.H_dr_Q1_p = Qflatten(tensor(OP['p'], OP['I'], OP['I']))
		self.H_dr_Q2_p = Qflatten(tensor(OP['I'], OP['p'], OP['I']))
		self.H_dr_Q3_p = Qflatten(tensor(OP['I'], OP['I'], OP['p']))


	def generateHamiltonian_3Q_cap(self):
		# construct 3-qubit Hamiltonian
		self.generateSubHamiltonian_3Q()
		# self Hamiltonian
		self.H_Q1 = self.dFreq_Q1 * self.H_Q1_aa + self.dAnh_Q1/2 * self.H_Q1_aaaa
		self.H_Q2 = self.dFreq_Q2 * self.H_Q2_aa + self.dAnh_Q2/2 * self.H_Q2_aaaa
		self.H_Q3 = self.dFreq_Q3 * self.H_Q3_aa + self.dAnh_Q3/2 * self.H_Q3_aaaa
		# coupling Hamiltonian
		self.g_12 = 0.5 * self.c12 * np.sqrt(self.dFreq_Q1 * self.dFreq_Q2)
		self.H_12 = self.g_12 * self.H_12_pp
		self.g_23 = 0.5 * self.c23 * np.sqrt(self.dFreq_Q2 * self.dFreq_Q3)
		self.H_23 = self.g_23 * self.H_23_pp
		self.g_13 = 0.5 * (self.c12 * self.c23 + self.c13) * np.sqrt(self.dFreq_Q1 * self.dFreq_Q3)
		self.H_13 = self.g_13 * self.H_13_pp
		# system Hamiltonian
		self.H_sys = self.H_Q1 + self.H_Q2 + self.H_Q3 + self.H_12 + self.H_23 + self.H_13


	def generateLabel_3Q(self):
		# generate 3-qubit number state label list
		list_label_gen = ["0","1","2","3","4","5","6","7"]
		self.list_label_table = []
		for k1 in np.arange(self.nTrunc):
			for k2 in np.arange(self.nTrunc):
				for k3 in np.arange(self.nTrunc):
					self.list_label_table.append(list_label_gen[k1] + list_label_gen[k2] + list_label_gen[k3])





class Driver(InstrumentDriver.InstrumentWorker):
	""" This class implements eigensolver of a multi-qubit system"""

	def performOpen(self, options={}):
		"""Perform the operation of opening the instrument connection"""
		# init variables
		self.multiqubit = MultiQubitHamiltonian()
		# self.vPolarization = np.zeros((4,))
		# self.lTrace = [np.array([], dtype=float) for n in range(4)]


	def performSetValue(self, quant, value, sweepRate=0.0, options={}):
		"""Perform the Set Value instrument operation. This function should
		return the actual value set by the instrument"""
		# do nothing, just return value
		return value


	def performGetValue(self, quant, options={}):
		"""Perform the Get Value instrument operation"""
		# dElevels = {'Eigenenergies unlabel': 0, 'Eigenenergies label': 1}
		# dPolarization = {'Polarization - X': 0, 'Polarization - Y': 1, 'Polarization - Z': 2, '3rd Level Population': 3}
		# check type of quantity
		if quant.name in list({'Eigenenergies unlabel'}) + list({'Eigenenergies label'}):
			# output data, check if simulation needs to be performed
			if self.isConfigUpdated():
				self.performSimulation()
			# get new value
			if quant.name == 'Eigenenergies unlabel':
				value = quant.getTraceDict(self.vals_unlabel_show*1E9, dt=1)
			if quant.name == 'Eigenenergies label':
				value = quant.getTraceDict(self.vals_label_show*1E9, dt=1)
		else:
			# otherwise, just return current value
			value = quant.getValue()
		return value


	def performSimulation(self):
		"""Perform simulation"""
		# get config values
		Config = dict(
					nQubit = int(self.getValue('Number of Qubits')),
					nTrunc = int(self.getValue('Degree of Trunction')),
					nShow = int(self.getValue('Max Number of Display')),
					bDesignParam_Q1 = bool(self.getValue('Q1 Use Design Parameter')),
					bDesignParam_Q2 = bool(self.getValue('Q2 Use Design Parameter')),
					bDesignParam_Q3 = bool(self.getValue('Q3 Use Design Parameter')),
					sQubitType_Q1 = self.getValue('Q1 Type'),
					sQubitType_Q2 = self.getValue('Q2 Type'),
					sQubitType_Q3 = self.getValue('Q3 Type'),
					dFreq_Q1 = self.getValue('Q1 Frequency')/1E9,
					dFreq_Q2 = self.getValue('Q2 Frequency')/1E9,
					dFreq_Q3 = self.getValue('Q3 Frequency')/1E9,
					dAnh_Q1 = self.getValue('Q1 Anharmonicity')/1E9,
					dAnh_Q2 = self.getValue('Q2 Anharmonicity')/1E9,
					dAnh_Q3 = self.getValue('Q3 Anharmonicity')/1E9,
					dC1 = self.getValue('Capacitance 1')*1E15,
					dC2 = self.getValue('Capacitance 2')*1E15,
					dC3 = self.getValue('Capacitance 3')*1E15,
					dC12 = self.getValue('Capacitance 12')*1E15,
					dC23 = self.getValue('Capacitance 23')*1E15,
					dC13 = self.getValue('Capacitance 13')*1E15,
					dEj_Q1 = self.getValue('Q1 Ej')/1E9,
					dEj_Q2 = self.getValue('Q2 Ej')/1E9,
					dEj_Q3 = self.getValue('Q3 Ej')/1E9,					
					dEc_Q1 = self.getValue('Q1 Ec')/1E9,
					dEc_Q2 = self.getValue('Q2 Ec')/1E9,
					dEc_Q3 = self.getValue('Q3 Ec')/1E9,
					dAsym_Q1 = self.getValue('Q1 Asymmetry'),
					dAsym_Q2 = self.getValue('Q2 Asymmetry'),
					dAsym_Q3 = self.getValue('Q3 Asymmetry'),
					dFlux_Q1 = self.getValue('Q1 Flux Bias'),
					dFlux_Q2 = self.getValue('Q2 Flux Bias'),
					dFlux_Q3 = self.getValue('Q3 Flux Bias'))
		# update config
		self.multiqubit.updateSimCfg(Config)
		if self.multiqubit.nQubit == 1:
			self.multiqubit.generateLabel_1Q()
			self.multiqubit.list_label_select = ["0","1","2","3"]
			self.multiqubit.generateHamiltonian_1Q_cap()
		if self.multiqubit.nQubit == 2:
			self.multiqubit.generateLabel_2Q()
			self.multiqubit.list_label_select = ["00","10","01","11","20","02"]
			self.multiqubit.generateHamiltonian_2Q_cap()
		elif self.multiqubit.nQubit == 3:
			self.multiqubit.generateLabel_3Q()
			self.multiqubit.list_label_select = ["000","100","010","001","110","101","011","200","020","002"]
			self.multiqubit.generateHamiltonian_3Q_cap()
		#
		# find eigensolution of system Hamiltonian
		self.multiqubit.vals_unlabel, self.multiqubit.vecs_unlabel = eigensolve(self.multiqubit.H_sys)
		self.multiqubit.vals_label, self.multiqubit.vecs_label = level_identify(self.multiqubit.vals_unlabel, self.multiqubit.vecs_unlabel, self.multiqubit.list_label_table, self.multiqubit.list_label_select)
		self.vals_unlabel_show = self.multiqubit.vals_unlabel[:self.multiqubit.nShow]
		self.vals_label_show = self.multiqubit.vals_label[:self.multiqubit.nShow]


if __name__ == '__main__':
	pass

