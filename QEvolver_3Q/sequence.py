# -*- coding: utf-8 -*-
"""
@author: Fei Yan
"""

import numpy as np
from scipy.linalg import eig
from qutip import *

import logging
log = logging.getLogger('LabberDriver')

# import scipy.constants as const
# #Constants.
# h = const.h #planck constant
# h_bar = const.hbar #h_bar
# e = const.e #electron charge
# phi0= h/(2*e) #flux quantum
# RQ = h/(2*e)**2 #quantum resistance


### basic functions ###
def Ej_SQUID(flux,Ej_sum,d):
	# effective Ej of a SQUID
	return Ej_sum * np.abs(np.cos(np.pi*flux)) * np.sqrt(1+d**2*np.tan(np.pi*flux)**2) #[GHz]

def freq_SQUID(Ej, Ec):
	return np.sqrt(8 * Ej * Ec) - Ec

def freq_LC(L,C):
	# frequency of LC oscillator
	# L [nH]
	# C [fH]
	return 1/(2*np.pi)/np.sqrt(L*C)/1e-3   #[GHz]

def Z_LC(L,C):
	# impedence of LC oscillator
	return np.sqrt(L/C)*1e3   #[Ohm]

def U(H,t):
	# unitary propagator generated by H over time t 
	H = Qobj(H)
	return Qobj(-1j * H * t).expm()

def T(A, U):
	A = Qobj(A)
	U = Qobj(U)
	return U * A * U.dag()

def Qflatten(Q):
	return Qobj(Q.full())

def eigensolve(H):
	# find eigensolution of H
	H = H.full()
	vals, vecs = eig(H)    
	#idx = vals.argsort()[::-1] #Descending Order
	idx = vals.argsort() #Ascending Order
	vals = vals[idx]
	vecs = vecs[:,idx]
	return np.real(vals), vecs

def level_identify(vals, vecs, list_table, list_select):
	# identify and sort eigen solutions according to "list_select"
	v_idx = []
	for k, str_level in enumerate(list_select):
		idx_sort = np.argsort(np.abs(vecs[list_table.index(str_level),:]))
		count = 1
		while True:
			if idx_sort[-count] in v_idx:
				count += 1
			else:
				v_idx.append(idx_sort[-count])
				break			
	return vals[v_idx], vecs[:,v_idx]


### sequence generating fucnctions ###
# rise/fall generating functions
def UNIT_RAMP(t):
	return 1-t

def UNIT_COS(t):
	return np.cos(np.pi*t)

# exception for GAUSS/EXP/REVERSEEXP
def UNIT_GAUSS(t):
	return np.exp(-t**2)

def UNIT_EXP(t):
	return np.exp(-t)

def UNIT_REVERSEEXP(t):
	return np.exp(-np.abs(t))

#
def gen_fall(t, pulseCfg):
	return {
	'RAMP': UNIT_RAMP(t),
	'COS': UNIT_COS(t/pulseCfg.STRETCH),
	'GAUSS': UNIT_GAUSS(t/pulseCfg.STRETCH),
	'EXP': UNIT_EXP(t/pulseCfg.STRETCH),
	'EXPFLIP': 1-UNIT_EXP((1-t)/pulseCfg.STRETCH)
	}[pulseCfg.RISE_SHAPE]

def add_fall(t, pulseCfg):
	return (gen_fall(t/pulseCfg.FALL, pulseCfg) - gen_fall(1, pulseCfg)) / (gen_fall(0, pulseCfg) - gen_fall(1, pulseCfg))

def add_rise(t, pulseCfg):
	return (gen_fall(-t/pulseCfg.RISE, pulseCfg) - gen_fall(1, pulseCfg)) / (gen_fall(0, pulseCfg) - gen_fall(1, pulseCfg))

def add_pulse(t, pulseCfg):
	# add single pulse
	pulseCfg.START = pulseCfg.PLATEAU_START - pulseCfg.RISE
	pulseCfg.PLATEAU_END = pulseCfg.PLATEAU_START + pulseCfg.PLATEAU
	pulseCfg.END = pulseCfg.PLATEAU_END + pulseCfg.FALL
	if t < pulseCfg.START:
		y = 0
	elif pulseCfg.START <= t < pulseCfg.PLATEAU_START:
		y = add_rise(t - pulseCfg.PLATEAU_START, pulseCfg)
	elif pulseCfg.PLATEAU_START <= t < pulseCfg.PLATEAU_END:
		y = 1
	elif pulseCfg.PLATEAU_END <= t < pulseCfg.END:
		y = add_fall(t - pulseCfg.PLATEAU_END, pulseCfg)
	elif t >= pulseCfg.END:
		y = 0
	return y * pulseCfg.AMPLITUDE * np.cos(pulseCfg.FREQUENCY * t + pulseCfg.PHASE)

def add_sequence(t, seqCfg):
	# add a sequence
	y = 0
	for n in range(seqCfg.nPulses):
		y += addPulse(t, seqCfg.lpulseCfg[n])
	return y



# class QubitConfiguration(Object):

# 	def __init__(self):
# 		self.UseDesignParam = 0
# 		self.QubitType = '2-JJ'
# 		self.Freq = 4.0
# 		self.Anh = -0.3
# 		self.Ej = 10.0
# 		self.Ec = 0.2
# 		self.Asym = 0.0
# 		self.Flux = 0.0
# 		self.PHASE = 0.0


class QubitConfiguration():

	def __init__(self, sQubit):
		self.sQubit = sQubit
		self.UseDesignParam = bool(self.getValue(self.sQubit + ' Use Design Parameter'))
		self.QubitType = self.getValue(self.sQubit + ' Type')
		self.Freq = self.getValue(self.sQubit + ' Frequency')/1E9
		self.Anh = self.getValue(self.sQubit + ' Anharmonicity')/1E9
		self.Ej = self.getValue(self.sQubit + ' Ej')/1E9
		self.Ec = self.getValue(self.sQubit + ' Ec')/1E9
		self.Asym = self.getValue(self.sQubit + ' Asymmetry')
		self.Flux = self.getValue(self.sQubit + ' Flux Bias')


class CapacitanceConfiguration():

	def __init__(self):
		self.dC1 = self.getValue('Capacitance 1')*1E15
		self.dC2 = self.getValue('Capacitance 2')*1E15
		self.dC3 = self.getValue('Capacitance 3')*1E15
		self.dC12 = self.getValue('Capacitance 12')*1E15
		self.dC23 = self.getValue('Capacitance 23')*1E15
		self.dC13 = self.getValue('Capacitance 13')*1E15
		self.r12 = self.dC12 / np.sqrt(self.dC1 * self.dC2)
		self.r23 = self.dC23 / np.sqrt(self.dC2 * self.dC3)
		self.r13 = self.r12 * self.r23 + self.dC13 / np.sqrt(self.dC1 * self.dC3)


class PulseConfiguration():

	def __init__(self):
		self.RISE_SHAPE = 'GAUSS'
		self.PLATEAU_START = 0.0
		self.RISE = 5.0
		self.PLATEAU = 0.0
		self.FALL = 5.0
		self.STRETCH = 0.5
		self.AMPLITUDE = 1.0
		self.FREQUENCY = 5.0
		self.PHASE = 0.0


class SequenceConfiguration():

	def __init__(self, sQubit, sSeqType):
		self.sQubit = sQubit
		self.sSeqType = sSeqType
		self.nPulses = int(self.getValue('Seq ' + self.sQubit + ' ' + self.sSeqType + ': Pulse Number'))
		self.lpulseCfg = []
		for n in range(self.nPulses):
			pulseCfg = PulseConfiguration()
			pulseCfg.RISE_SHAPE = self.getValue('Seq ' + self.sQubit + ' ' + self.sSeqType + ': Shape #%d' %(n+1))
			pulseCfg.PLATEAU_START = self.getValue('Seq ' + self.sQubit + ' ' + self.sSeqType + ': Plateau Start #%d' %(n+1))
			pulseCfg.RISE = self.getValue('Seq ' + self.sQubit + ' ' + self.sSeqType + ': Rise #%d' %(n+1))
			pulseCfg.PLATEAU = self.getValue('Seq ' + self.sQubit + ' ' + self.sSeqType + ': Plateau #%d' %(n+1))
			pulseCfg.FALL = self.getValue('Seq ' + self.sQubit + ' ' + self.sSeqType + ': Fall #%d' %(n+1))
			pulseCfg.STRETCH = self.getValue('Seq ' + self.sQubit + ' ' + self.sSeqType + ': Stretch #%d' %(n+1))
			pulseCfg.AMPLITUDE = self.getValue('Seq ' + self.sQubit + ' ' + self.sSeqType + ': Amplitude #%d' %(n+1))
			pulseCfg.FREQUENCY = self.getValue('Seq ' + self.sQubit + ' ' + self.sSeqType + ': Frequency #%d' %(n+1))
			pulseCfg.PHASE = self.getValue('Seq ' + self.sQubit + ' ' + self.sSeqType + ': Phase #%d' %(n+1))
			self.lpulseCfg.append(pulseCfg)

	# def timeFunc(self, t):
	# 	self.bDesignParam = self.getValue(self.sQubit + ' ' + 'Use Design Parameter')
	# 	if self.bDesignParam:
	# 		self.dEj = self.getValue(self.sQubit + ' ' + 'Ej')
	# 		self.dEc = self.getValue(self.sQubit + ' ' + 'Ec')
	# 		self.dAsym = self.getValue(self.sQubit + ' ' + 'Asym')
	# 		self.dFlux = self.getValue(self.sQubit + ' ' + 'Flux')
	# 		self.timeFlux = add_sequence(t, self.seqCfg) + self.dFlux
	# 		self.timeEj = Ej_SQUID(self.timeFlux, self.dEj_Q1, self.dAsym_Q1)
	# 		return freq_SQUID(self.timeEj, self.dEc)
	# 	elif self.sSeqType == ['Frequency', 'Anharmonicity']:
	# 		self.dOffset = self.getValue(self.sQubit + ' ' + self.sSeqType)
	# 	else:
	# 		self.dOffset = 0
	# 	return add_sequence(t, self.seqCfg) + self.dOffset

# class QubitState():

# 	def __init__(self):



class Simulation():

	def __init__(self):
		# init with some default settings
		self.nQubit = int(self.getValue('Number of Qubits')),
		self.nTrunc = int(self.getValue('Degree of Trunction'))
		self.dTimeStart = self.getValue('Time Start')
		self.dTimeEnd = self.getValue('Time End')
		self.nTimeList = int(self.getValue('Number of Samples'))
		self.tlist = np.linspace(self.dTimeStart, self.dTimeEnd, self.nTimeList)
		self.dt = self.tlist[1] - self.tlist[0]	
		# self.nShow = 4
		self.qubitCfg_Q1 = QubitConfiguration('Q1')
		self.qubitCfg_Q2 = QubitConfiguration('Q2')
		self.qubitCfg_Q3 = QubitConfiguration('Q3')
		#
		self.capCfg = CapacitanceConfiguration()
		#
		self.lSeq = ['Q1 Frequency', 'Q1 Anharmonicity', 'Q2 Frequency', 'Q2 Anharmonicity', 'Q3 Frequency', 'Q3 Anharmonicity', 'Q1 DriveP', 'Q2 DriveP', 'Q3 DriveP']
		self.seqCfg_Q1_Freq = SequenceConfiguration('Q1','Frequency')
		self.seqCfg_Q1_Anh = SequenceConfiguration('Q1','Anh')
		self.seqCfg_Q2_Freq = SequenceConfiguration('Q2','Frequency')
		self.seqCfg_Q2_Anh = SequenceConfiguration('Q2','Anh')
		self.seqCfg_Q3_Freq = SequenceConfiguration('Q3','Frequency')
		self.seqCfg_Q3_Anh = SequenceConfiguration('Q3','Anh')
		self.seqCfg_Q1_DriveP = SequenceConfiguration('Q1','DriveP')
		self.seqCfg_Q2_DriveP = SequenceConfiguration('Q2','DriveP')
		self.seqCfg_Q3_DriveP = SequenceConfiguration('Q3','DriveP')

		self.a00 = self.getValue('a00')
		self.a01 = self.getValue('a01')
		self.a10 = self.getValue('a10')
		self.a11 = self.getValue('a11')
		self.psi_input_logic = Qobj(np.array([self.a00,self.a01,self.a10,self.a11])).unit()
		self.rho_input_logic = self.psi_input_logic * self.psi_input_logic.dag()


	# def updateSimCfg(self, simCfg):
	# 	# update simulation options
	# 	for key, value in simCfg.items():
	# 		if hasattr(self, key):
	# 			setattr(self, key, value)
	# 	# update capacitance coupling coefficient
	# 	self.c12 = self.dC12 / np.sqrt(self.dC1 * self.dC2)
	# 	self.c23 = self.dC23 / np.sqrt(self.dC2 * self.dC3)
	# 	self.c13 = self.dC13 / np.sqrt(self.dC1 * self.dC3)
	# 	# update frequencies if using designer parameter set
	# 	if self.bDesignParam_Q1:
	# 		if self.sQubitType_Q1 == '2-JJ':
	# 			setattr(self, 'dFreq_Q1', freq_SQUID(Ej_SQUID(self.dFlux_Q1,self.dEj_Q1,self.dAsym_Q1), self.dEc_Q1))
	# 			setattr(self, 'dAnh_Q1', -self.dEc_Q1)
	# 	if self.bDesignParam_Q2:
	# 		if self.sQubitType_Q2 == '2-JJ':
	# 			setattr(self, 'dFreq_Q2', freq_SQUID(Ej_SQUID(self.dFlux_Q2,self.dEj_Q2,self.dAsym_Q2), self.dEc_Q2))
	# 			setattr(self, 'dAnh_Q2', -self.dEc_Q2)
	# 	if self.bDesignParam_Q3:
	# 		if self.sQubitType_Q3 == '2-JJ':
	# 			setattr(self, 'dFreq_Q3', freq_SQUID(Ej_SQUID(self.dFlux_Q3,self.dEj_Q3,self.dAsym_Q3), self.dEc_Q3))
	# 			setattr(self, 'dAnh_Q3', -self.dEc_Q3)


	def generateOperators(self):
		# generate basic operators. matrix truncated at nTrunc 
		I = qeye(self.nTrunc)
		a = destroy(self.nTrunc)
		x = a + a.dag()
		p = -1j*(a - a.dag())
		aa = a.dag() * a
		aaaa = a.dag() * a.dag() * a * a
		return {'I':I, 'a':a, 'x':x, 'p':p, 'aa':aa, 'aaaa':aaaa}


	def generateSubHamiltonian_3Q(self):
		# generate partial Hamiltonian in 3-qubit system
		OP = self.generateOperators()
		self.OP = OP
		# self Hamiltonian operators
		self.H_Q1_aa = Qflatten(tensor(OP['aa'], OP['I'], OP['I']))
		self.H_Q1_aaaa = Qflatten(tensor(OP['aaaa'], OP['I'], OP['I']))
		self.H_Q2_aa = Qflatten(tensor(OP['I'], OP['aa'], OP['I']))
		self.H_Q2_aaaa = Qflatten(tensor(OP['I'], OP['aaaa'], OP['I']))
		self.H_Q3_aa = Qflatten(tensor(OP['I'], OP['I'], OP['aa']))
		self.H_Q3_aaaa = Qflatten(tensor(OP['I'], OP['I'], OP['aaaa']))
		# coupling Hamiltonian operators
		self.H_g12_xx = Qflatten(tensor(OP['x'], OP['x'], OP['I']))
		self.H_g23_xx = Qflatten(tensor(OP['I'], OP['x'], OP['x']))
		self.H_g13_xx = Qflatten(tensor(OP['x'], OP['I'], OP['x']))		#
		self.H_g12_pp = Qflatten(tensor(OP['p'], OP['p'], OP['I']))
		self.H_g23_pp = Qflatten(tensor(OP['I'], OP['p'], OP['p']))
		self.H_g13_pp = Qflatten(tensor(OP['p'], OP['I'], OP['p']))
		# drive Hamiltonian operators
		self.H_Q1_dr_x = Qflatten(tensor(OP['x'], OP['I'], OP['I']))
		self.H_Q2_dr_x = Qflatten(tensor(OP['I'], OP['x'], OP['I']))
		self.H_Q3_dr_x = Qflatten(tensor(OP['I'], OP['I'], OP['x']))
		self.H_Q1_dr_p = Qflatten(tensor(OP['p'], OP['I'], OP['I']))
		self.H_Q2_dr_p = Qflatten(tensor(OP['I'], OP['p'], OP['I']))
		self.H_Q3_dr_p = Qflatten(tensor(OP['I'], OP['I'], OP['p']))
		# collapse operators
		self.L_Q1_a = Qflatten(tensor(OP['a'], OP['I'], OP['I']))
		self.L_Q2_a = Qflatten(tensor(OP['I'], OP['a'], OP['I']))
		self.L_Q3_a = Qflatten(tensor(OP['I'], OP['I'], OP['a']))


	def generateHamiltonian_3Q_cap(self):
		# construct 3-qubit Hamiltonian
		self.generateSubHamiltonian_3Q()
		# self Hamiltonian
		self.H_Q1 = self.qubitCfg_Q1.Freq * self.H_Q1_aa + self.qubitCfg_Q1.Anh/2 * self.H_Q1_aaaa
		self.H_Q2 = self.qubitCfg_Q2.Freq * self.H_Q2_aa + self.qubitCfg_Q2.Anh/2 * self.H_Q2_aaaa
		self.H_Q3 = self.qubitCfg_Q3.Freq * self.H_Q3_aa + self.qubitCfg_Q3.Anh/2 * self.H_Q3_aaaa
		# coupling Hamiltonian
		self.g12_pp = 0.5 * self.capCfg.r12 * np.sqrt(self.qubitCfg_Q1.Freq * self.qubitCfg_Q2.Freq)
		self.H_12 = self.g12_pp * self.H_g12_pp
		self.g23_pp = 0.5 * self.capCfg.r23 * np.sqrt(self.qubitCfg_Q2.Freq * self.qubitCfg_Q3.Freq)
		self.H_23 = self.g23_pp * self.H_g23_pp
		self.g13_pp = 0.5 * self.capCfg.r13 * np.sqrt(self.qubitCfg_Q1.Freq * self.qubitCfg_Q3.Freq)
		self.H_13 = self.g13_pp * self.H_g13_pp
		# system Hamiltonian
		self.H_sys = self.H_Q1 + self.H_Q2 + self.H_Q3 + self.H_12 + self.H_23 + self.H_13


	def generateLabel_3Q(self):
		# generate 3-qubit number state label list
		list_label_gen = [str(n) for n in range(16)]
		self.list_label_table = []
		for k1 in np.arange(self.nTrunc):
			for k2 in np.arange(self.nTrunc):
				for k3 in np.arange(self.nTrunc):
					self.list_label_table.append(list_label_gen[k1] + list_label_gen[k2] + list_label_gen[k3])


	def generateCollapse_3Q(self):
		self.c_ops = [np.sqrt(self.Gamma1_Q1) * L_Q1_a,
					 np.sqrt(self.Gamma1_Q2) * L_Q2_a,
					 np.sqrt(self.Gamma1_Q3) * L_Q3_a]



class SequenceConfiguration():

	def __init__(self, sQubit, sSeqType):
		self.sQubit = sQubit
		self.sSeqType = sSeqType
		self.nPulses = int(self.getValue('Seq ' + self.sQubit + ' ' + self.sSeqType + ': Pulse Number'))
		self.lpulseCfg = []
		for n in range(self.nPulses):
			pulseCfg = PulseConfiguration()
			pulseCfg.RISE_SHAPE = self.getValue('Seq ' + self.sQubit + ' ' + self.sSeqType + ': Shape #%d' %(n+1))
			pulseCfg.PLATEAU_START = self.getValue('Seq ' + self.sQubit + ' ' + self.sSeqType + ': Plateau Start #%d' %(n+1))
			pulseCfg.RISE = self.getValue('Seq ' + self.sQubit + ' ' + self.sSeqType + ': Rise #%d' %(n+1))
			pulseCfg.PLATEAU = self.getValue('Seq ' + self.sQubit + ' ' + self.sSeqType + ': Plateau #%d' %(n+1))
			pulseCfg.FALL = self.getValue('Seq ' + self.sQubit + ' ' + self.sSeqType + ': Fall #%d' %(n+1))
			pulseCfg.STRETCH = self.getValue('Seq ' + self.sQubit + ' ' + self.sSeqType + ': Stretch #%d' %(n+1))
			pulseCfg.AMPLITUDE = self.getValue('Seq ' + self.sQubit + ' ' + self.sSeqType + ': Amplitude #%d' %(n+1))
			pulseCfg.FREQUENCY = self.getValue('Seq ' + self.sQubit + ' ' + self.sSeqType + ': Frequency #%d' %(n+1))
			pulseCfg.PHASE = self.getValue('Seq ' + self.sQubit + ' ' + self.sSeqType + ': Phase #%d' %(n+1))
			self.lpulseCfg.append(pulseCfg)


class sequence():

	def __initial__(self, config):
		#
		for sQubit in List_sQubit:
			for sSeqType in List_sSeqType
				_name_to = 'seqCfg_' + sQubit + '_' + sSeqType
				setattr(self, , 42)
				self.seqCfg_Q1_Freq = SequenceConfiguration(sQubit, sSeqType)
				name_input = 'Seq ' + sQubit + ' ' + sSeqType + ' ' + sPulseParam + '#d' %
				name_
				self.
		self.seqCfg_Q1_Freq = SequenceConfiguration('Q1','Frequency')
		self.seqCfg_Q1_Anh = SequenceConfiguration('Q1','Anh')
		self.seqCfg_Q2_Freq = SequenceConfiguration('Q2','Frequency')
		self.seqCfg_Q2_Anh = SequenceConfiguration('Q2','Anh')
		self.seqCfg_Q3_Freq = SequenceConfiguration('Q3','Frequency')
		self.seqCfg_Q3_Anh = SequenceConfiguration('Q3','Anh')
		self.seqCfg_Q1_DriveP = SequenceConfiguration('Q1','DriveP')
		self.seqCfg_Q2_DriveP = SequenceConfiguration('Q2','DriveP')
		self.seqCfg_Q3_DriveP = SequenceConfiguration('Q3','DriveP')
		self.period_1qb = config.get('Pulse period, 1-QB')

	### generate coefficient ###
	def	timeFunc_Q1_Freq(self,t):
		return add_sequence(t, self.seqCfg_Q1_Freq) + self.qubitCfg_Q1.Freq

	def	timeFunc_Q1_Anh(self,t):
		return add_sequence(t, self.seqCfg_Q1_Anh) + self.qubitCfg_Q1.Anh

	def	timeFunc_Q2_Freq(self,t):
		return add_sequence(t, self.seqCfg_Q2_Freq) + self.qubitCfg_Q2.Freq

	def	timeFunc_Q2_Anh(self,t):
		return add_sequence(t, self.seqCfg_Q2_Anh) + self.qubitCfg_Q2.Anh

	def	timeFunc_Q3_Freq(self,t):
		return add_sequence(t, self.seqCfg_Q3_Freq) + self.qubitCfg_Q3.Freq

	def	timeFunc_Q3_Anh(self,t):
		return add_sequence(t, self.seqCfg_Q3_Anh) + self.qubitCfg_Q3.Anh

	def	timeFunc_g12_pp(self,t):
		return 0.5 * self.capCfg.r12 * np.sqrt(self.timeFunc_Q1_Freq(t) * self.timeFunc_Q2_Freq(t))

	def	timeFunc_g23_pp(self,t):
		return 0.5 * self.capCfg.r23 * np.sqrt(self.timeFunc_Q2_Freq(t) * self.timeFunc_Q3_Freq(t))

	def	timeFunc_g13_pp(self,t):
		return 0.5 * self.capCfg.r13 * np.sqrt(self.timeFunc_Q1_Freq(t) * self.timeFunc_Q3_Freq(t))

	def	timeFunc_Q1_DriveP(self,t):
		return add_sequence(t, self.seqCfg_Q1_DriveP)

	def	timeFunc_Q2_DriveP(self,t):
		return add_sequence(t, self.seqCfg_Q2_DriveP)

	def	timeFunc_Q3_DriveP(self,t):
		return add_sequence(t, self.seqCfg_Q3_DriveP)

	def generateSeqOutput(self):
		#
		strT = 'Time Series: '
		self.dict_seq = {strT + s : [] for s in self.lSeq}
		for k, t in enumerate(self.tlist):
			self.dict_seq[strT + 'Q1 Frequency'].append(self.timeFunc_Q1_Freq(t))
			self.dict_seq[strT + 'Q1 Anharmonicity'].append(self.timeFunc_Q1_Anh(t))
			self.dict_seq[strT + 'Q2 Frequency'].append(self.timeFunc_Q2_Freq(t))
			self.dict_seq[strT + 'Q2 Anharmonicity'].append(self.timeFunc_Q2_Anh(t))
			self.dict_seq[strT + 'Q3 Frequency'].append(self.timeFunc_Q3_Freq(t))
			self.dict_seq[strT + 'Q3 Anharmonicity'].append(self.timeFunc_Q3_Anh(t))
			self.dict_seq[strT + 'Q2 DriveP'].append(self.timeFunc_Q2_DriveP(t))
			self.dict_seq[strT + 'Q3 DriveP'].append(self.timeFunc_Q3_DriveP(t))


	def generateInitialState(self):
		#
		self.generateLabel_3Q()
		self.list_label_sub = ["000","001","100","101"]
		self.vals_idle, self.vecs_idle = eigensolve(self.H_sys)
		self.vals_idle_sub, vecs_idle_sub = level_identify(self.vals_idle, self.vecs_idle, self.list_label_table, self.list_label_sub)
		self.U_sub = Qobj(self.vecs_sub)
		self.rho_input_rot = T(self.rho_input_logic, self.U_sub)
		self.rho0 = T(self.rho_input_rot, U(self.H_sys, self.tlist[0]))

	def rhoEvolver_3Q(self):
		#
		self.result = mesolve(H=[
			[2*np.pi*self.H_Q1_aa, self.timeFunc_Freq_Q1],
			[2*np.pi*self.H_Q1_aaaa, self.timeFunc_Anh_Q1],
			[2*np.pi*self.H_Q2_aa, self.timeFunc_Freq_Q2],
			[2*np.pi*self.H_Q2_aaaa, self.timeFunc_Anh_Q2],
			[2*np.pi*self.H_Q3_aa, self.timeFunc_Freq_Q3],
			[2*np.pi*self.H_Q3_aaaa, self.timeFunc_Anh_Q3],
			[2*np.pi*self.H_g12_pp, self.timeFunc_g12_pp],
			[2*np.pi*self.H_g23_pp, self.timeFunc_g23_pp],
			[2*np.pi*self.H_g13_pp, self.timeFunc_g13_pp],
			[2*np.pi*self.H_Q1_dr_p, self.timeFunc_Q1_DriveP],
			[2*np.pi*self.H_Q2_dr_p, self.timeFunc_Q2_DriveP],
			[2*np.pi*self.H_Q3_dr_p, self.timeFunc_Q2_DriveP]
			],
			rho0 = self.rho0, tlist = self.tlist, c_ops = self.c_ops, args = [])#, options = options), store_states=True, c_ops=[], e_ops=[]
		# return result.states


	def generateObservables(self):
		strT = 'Time Series: '
		list_pauli_label = ['I','X','Y','Z']
		list_pauli = [qeye(2), sigmax(), sigmay(), sigmaz()]
		self.dict_pauli = {}
		self.dict_tomo = {}
		for k1 in range(4):
			for k2 in range(4):
				key = list_pauli_label[k1] + list_pauli_label[k2]
				self.dict_pauli[key] = Qflatten(tensor(list_pauli[k1],list_pauli[k2]))
				self.dict_tomo[strT + key] = []
		#
		for k, t in enumerate(self.tlist):
			rho_lab = self.results.states[k]
			rho_rot = T(rho_lab, U(self.H_sys, t).dag())
			rho_logic = T(rho_rot, U_sub.dag())
			for key, op in self.dict_pauli.items():
				self.dict_tomo[strT + key].append((op * rho_logic).tr())


# class Noise():